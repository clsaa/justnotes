# 软件复杂度


## 什么是复杂系统

Jurgen Appelo 从理解能力与预测能力两个维度分析了复杂度的成因【2]39。这两个维度各自分为不同的复杂层次：

* 理解能力维度--简单的（simple）和复杂的（com- plicated);
* 预测能力维度--有序的（ordered）、复杂的（complex）和混沌的（chaotic）。

### 影响理解的要素

#### 规模

随着软件系统规模的扩张，软件复杂度也会增长。这种增长并非线性的，而是呈现出更加陡峭的指数级趋势。这实际上是软件的熵发挥着副作用。当软件中的无序化增加时，程序员会说'软件在腐烂'。

软件之所以无法躲避熵的重击，源于我们在构建软件时无法避免技术债（technicaldebt）注。不管软件的架构师与开发人员有多么的优秀，他们针对目前需求做出的看似合理的技术决策，都会随着软件的演化变得不堪一击，区别仅在于债务的多少，以及偿还的利息有多高。

一方案就是尽量让它可见，例如通过技术债列表或者技术债冒达等可视化形式及时呈现给团队成员，并制订计划主动地消除或低技术债

<img width="914" alt="image" src="https://github.com/user-attachments/assets/ee79ab0f-2027-4801-b781-ed4155a39c6f">

#### 结构

从系统结构的视角看，单体架构一定比微服务架构更简单，为何还有这么多软件组织开始清算自己的软件资产，花费大量人力力物力对现有的单体架构进行重构，走向微服务化？究其主因，还是系统的质量属性。

康威定律（Conway's law）注就指出：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。”Sam Newman 认为是需要“适应沟通途径”使得康威定律在软件结构与组织结构中生效。他分析了一种典型的分处异地的分布式团队。整个团队共享单个服务的代码所有权，由于分布式团队的地域和时区界限使得沟通成本变高，因此团队之间只能进行粗粒度的沟通。当协调变化的成本增加后，人们就会想方设法降低协调和沟通的成本。直截了当的做法就是分解代码，分配代码所有权，物理分隔的团队各自负责一部分代码库，从而能够更容易地修改代码，团队之间会有更多关于如何集成两部分代码的粗粒度的沟通。最终，与这种沟通路径匹配形成的粗粒度应用程序编程接口（application programming interface, API）构成了代码库中两部分之间的边界。

现代软件神话“详细地罗列了无序设计系统的几种警告信号
* 代码没有显而易见的进入系统中的路径；
* 不存在一致性，不存在风格，也没有能够将不同的部分组织在在一起的统一概念系统中的控制流让人觉得不舒服，无法预测；
* 系统中有太多的”坏味道“;
* 数据很少放在它被使用的地方，经常引入额外的巴洛克式缓存层，试图让数据停留在更方便的地方。

#### 预测


* 过度设计：设计软件系统时，变化让我们患得患失，不知道如何把握系统设计十的度。若拒绝对变化做出理智的预测，系统的设计会变得僵化，一旦有新的变化发生，修改的成本会非常大；若过于看重变化产生的影响，渴望涵盖一切变化的可能，若预期的变化没有发生生，我们之前为变化付出的成本就再也补偿不回来了，这就是所谓的“过度设计”
* 设计不足：要应对需求变化，终归需要一些设计技巧。很多时候，因为设计人员的技能不足，没有明确识别出未来确认会发生的变化，可者对需求变化发展的方向缺乏前瞻，所以导致整个设计变得过于僵化，修改的成本太高，从而走向了过度设计的另外一个极端，我将这一问题称为“设计不足”。设计不足的方案只顾眼前，对于一定要发生的变化视而不见，这不仅导致方案缺乏可扩展性，甚至有可能出现技术实现方向的错误。这样的设计不是恰如其分的简单设计，而是对于糟糕质量视而不见的简陋处置，是为了应付进度蒙混过关用的临时花招，表面看来满足了进度要求，但在未来偿还欠下的债务时，需要付出厂几倍的成本。

# DDD概览

## DDD与软件复杂度

DDD用来应对软件复杂度挑战，复杂度的成因是什么？

* 规模--通过分而治之控制规模：以子领域、限界上下文对问题空间与解空间分而治之；
* 结构--通过边界保证清晰有序：以分层架构隔离业务复杂度与技术复杂度，形成清晰的架构；
* 变化--顺应变化方向：通过领域建模抽象为以聚合为核心的领域模型，响应需求之变化。

领域驱动设计统一过程分为 3 个阶段：

* 全局分析阶段；
* 架构映射阶段；
* 领域建模阶段。

## DDD元模型

![image](https://github.com/user-attachments/assets/589b59a8-7f1d-42f0-9349-d5313f09304d)

模型驱动设计可以在限界上下文的边界内部进行，它通过分层架构（layered architecture）将领域独立出来，并在统一语言的指导下，通过与领域专家的协作获得领域模型。表示领域模型的设计要素包括实体（entity）、值对象（value object）、领域服务（domain service）和领域事件（domain event）。领域逻辑都应该封装在这些对象中，这一严格的设计原则可以避免领域逻辑泄露到领域层之外，导致技术实现与领域逻辑的混淆。

聚合（aggregate)是一种边界，它可以封装一到多个实体与值对象，并维持该边界范围之内的业务完整性。聚合至少包含一个实体，且只有实体才能作为聚合根（aggregateroot）。工厂（factory）和资源库（repository)负责管理聚合的生命周期。前者负责聚合的创建，用于封装复杂或者可能变化的创建逻辑；后者负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改聚合。

软件系统的构建实则是对问题空间的求解，以获得构成解空间的设计方案

领域驱动设计为问题空间与解空间提供了不同的设计元模型。对于问题空间，强调运用统一语言来描述需求问题，利用核心子领域、通用子领域与支撑子领域来分解问题空间，如此就可以“揭示什么是重要的以及在何处付出努力”[1]。除去统一语言与子领域，其余设计元模型都将运用于解空间，指导解决方案围绕着“令域”这一核心开展业务系统的战略设计与战术设计。

### 战略设计和战术设计

不同层次的求解目标并不相同（这就是领域驱动设计的两个阶段：战略设计阶段和战术设计阶段）：
* 为了把握系统的全景，就需要从宏观层次分析和探索问题空间，获得对等于软件架构的战略设计原则；
* 为了深入业务的细节，则需要从微观层次开展建模活动，并在战略设计原则的指导下做出战术设计决策

战略设计考虑的重点：
* 问题空间：对问题空间进行合理分解，识别出核心子领域、通用子领域和支撑子领域，并确定各个子领域的目标、边界和建模策略。
* 解空间：对问题空间进行解决方案的架构映射，通过划分限界上下文，为统一语言提供知识语境，并在其边界内维护领域莫型的统一。每个限界上下文的内部有着自己的架构，限界上下文之间的协作关系则通过上下文映射来体现和表达。

战略设计与战术设计并非割裂的两个阶段，而是模型驱动设计过程在不同阶段展现出来的不同视图。战略设计指导着战术设计。这就等同于设计原则指导着设计决策。Eric Evans 就明确指出，“战略设计原则必须把模型的重点放在捕获系统的概念核心，也就是系统的'远景'上。当一个业务系统的规模变得越来越庞大时，战略设计高屋建瓴地通过限界上下文规划了整个系统的架构。只要维护好限界上下文的边界，管理好限界上下文之间的协作关系，|限制在该边界内开展的战术设计所要面对的就是一个复杂度得到大幅降低的小型业务系统。

从战略设计到战术设计是一个自顶向下的设计过程，体现为设计原则对设计决策的指导；将战术设计方案反馈给战略设计，则是自底向上的演化过程，体现为对领域概念的重构引起对战略架构的重构。二者形成不断演化、螺旋上升的设计循环。

战术设计阶段最重要的设计元模型是聚合模式。虽然聚合是实体和值对象的概念边界，然而在获得了清晰表达领域知识的领域模型后，我们可以将聚合视为表达领域逻辑的最小设计单元。女果领域行为是无状态的，或者需要多个聚合的协作，又或者需要访问外部资源，则应该将它分配给领域服务。至于领域事件，则主要要用于表达领域对象状态的迁移，也可以通过事件来实现聚合乃至限界上下文之间的状态通知。

### 领域设计过程

<img width="526" alt="image" src="https://github.com/user-attachments/assets/438233a3-988a-4e88-8ba2-a1d4d675bc07">

* 领域驱动设计的过程几乎贯穿了整个软件构建的生命周期，包括又村业务需求的探索和分析，系统的架构和设计，以及编码实现、测试和重构。面对客户的业务需求，由领域专家与开发团队展开充分的交流，经过需求分析与知识提炼，获得清晰明确的问题空间，并从问题空间的业务需求中提炼出统一语言，然后利用子领域分解问题空间，根据价值高低确定核心子领域、通用子领域和支撑子领域。
* 通过对问题空间开展战略层次的求解，获得限界上下文形成解空间的主要支撑元素。识别限界上下文的基础来自问题空间的业务需求，遵循“高内聚松耦合”的原则划分领域知识的边界，再通过过上下文映射管理它们之间的关系。每个限界上下文都是一个相对独立的“自治王国”，可以根据限界上下文是否属于核心子领域来选择择内部的架构。通常，需要通过分层架构将限界上下文内部的领域隔离出来，进入战术设计阶段，进行面向领域的模型驱动设计。
* 选定一个限界上下文，在统一语言的指导下，针对该上下文内部的领域知识开展领域模型驱动设计。首先进行领域分析，提炼领域知识建立满足统一语言要求的领域分析模型，然后引入实体、值对象、领域服务、领域事件、聚合、资源库和工厂等设计要素开始程序设计，获得设计模型后在它的指导下进行编码实现，输出最终的领域模型。
* 在领域驱动设计过程中，战略设计控制和分解了战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性和一致性，进而以迭代的方式分别完成对限界上下文与领域模型的更新与演化，各自形成设计过程的闭环。两个不同阶段的设设计目标保持一致，形成一个连贯的过程，彼此之间相互指导与规范，量终保证战略架构与领域模型的同时演进。











